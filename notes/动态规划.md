## DP经典类型

### 动规基础

### 背包问题

#### 01背包

##### 求最大能放的物品价值 (#416, #1049)

二维dp的转移方程:
其中`i`表示有`0-i`个物品，`j`表示当前背包的容量。

```js
dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])
```
二维的循环顺序可以对调，因为二维dp数组保存的信息较全，当前状态无需被前一个状态覆盖，完全可以对调。

一维dp的转移方程:
```js
dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i])
```
一维dp由于保存的信息较少，必须先遍历物品再遍历背包。如果先遍历背包, 由于倒序遍历的问题，只会拿初始化的dp对比，最终导致每次背包只会放入一个物品；且背包必须从后往前遍历，否则会产生一个物品放入多次的现象，因为背包信息会被前一个覆盖。

循环顺序对调后的代码:
```js
const nums = [1,2,3]
const value = 3

for (let i = value; i > 0; i--) {
  for (let j = 0; j < nums.length; j++) {
    // value = 3
    // dp[3] = max(dp[3], dp[2] + 1)
    // dp[3] = max(dp[3], dp[1] + 2)
    // dp[3] = max(dp[3], dp[0] + 3)
    // value = 2
    // dp[2] = max(dp[2], dp[1] + 1)
    // dp[2] = max(dp[2], dp[0] + 2)
    // value = 1
    // dp[1] = max(dp[1], dp[0] + 1)
    
    dp[i] = Math.max(dp[i], dp[i - nums[j]] + nums[j]);
  }
}
```
##### 求当价值最大时, 有几种放物品的方法 (#494)

二维dp的转移方程:

由于当数组长度为0时也许要计算方法数，所以dp的外层长度必须为`nums.length + 1`。
```js
dp[i][j] = dp[i - 1][j] + dp[i - 1][j - weight[i]]
```

一维dp的转移方程:
```js
dp[j] += dp[j - weight[i]]
```
#### 完全背包

##### 求最大能放的物品价值 

二维dp的转移方程:
其中`i`表示有`0-i`个物品，`j`表示当前背包的容量。

```js
dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - weight[i]] + value[i])
```
循环顺序可以对调。

一维dp的转移方程:
```js
dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i])
```
一维的状态转移方程和01背包的完全相同，由于完全背包只需要少量用到前一次遍历的值，所以背包容量遍历顺序必须从前往后遍历，且循环顺序可以对调。

##### 求当价值最大时, 有几种放物品的方法 (#518)

二维dp的转移方程:
其中`i`表示有`0-i`个物品，`j`表示当前背包的容量.

```js
dp[i][j] = dp[i - 1][j] + dp[i][j - weight[i]]
```

一维dp的转移方程:
```js
dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i])
```
如果循环顺序为先物品后背包：

假设最大价值为`6`，硬币为`[1, 5]`，这个循环顺序下，硬币组合只会得到`1`和`5` 而不会得到 `5`和`1`，所以此循环方法得到的是硬币有多少种组合方式。

如果循环顺序为先背包后物品：

假设最大价值为`6`，硬币为`[1, 5]`，这个循环顺序下，硬币组合会得到`1`和`5` 以及 `5`和`1`两种情况，所以此循环方法得到的是硬币有多少种排列方式。


### 打家劫舍

### 股票问题

### 子序列问题

  一个字符串、数组基本可以确定为一维dp table，两个字符串、数组基本可以确定为二维dp table。

## DP关键点

- dp数组及下标含义
- dp数组如何初始化
- 遍历顺序
- 递归公式

## 动态规划解题思路

1. 确定状态是什么,然后再一个一个递推过去试试？
2. 如果从前往后递推不能确定的话,试试从后往前递推 (#120 三角形最小路径和, #931 下降路径最小和)
3. dp table是一维的还是二维的？
4. 先用穷举,再优化试试？
5. 将固定公式移项、变形试试？
6. 当前状态是否只与上一个状态有关？会不会和再上一个状态有关呢？
7. 当前状态是不是还与上一个状态的对立面有关？(如: 最大值, 最小值) (#1567 乘积为正数的最长子数组长度, #367 摆动序列)
8. 两个循环的先后顺序问题？(#322 零钱兑换, #518 零钱兑换2)