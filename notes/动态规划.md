## DP经典类型
### 动规基础
### 背包问题
#### 01背包
##### 求最大能放的物品价值 (#416, #1049)
二维dp的转移方程:
其中`i`表示有`0-i`个物品, `j`表示当前背包的容量.
```js
dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])
```
二维的循环顺序可以对调, 因为二维dp数组保存的信息较全, 当前状态无需被前一个状态覆盖, 完全可以对调.

一维dp的转移方程:
```js
dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i])
```
一维dp由于保存的信息较少, 必须先遍历物品再遍历背包, 如果先遍历背包, 背包信息会被前一个覆盖, 会导致每次背包只会放入一个物品; 且背包必须从后往前遍历, 否则会产生一个物品放入多次的现象, 也是因为背包信息会被前一个覆盖.
##### 求当价值最大时, 有几种放物品的方法 (#494)
二维dp的转移方程:

由于当数组长度为0时也许要计算方法数, 所以dp的外层长度必须为`nums.length + 1`.
```js
dp[i][j] = dp[i - 1][j] + dp[i - 1][j - weight[i]]
```

一维dp的转移方程:
```js
dp[j] += dp[i - 1][j - weight[i]]
```
### 打家劫舍
### 股票问题
### 子序列问题
  一个字符串、数组基本可以确定为一维dp table, 两个字符串、数组基本可以确定为二维dp table

## DP关键点
- dp数组及下标含义
- dp数组如何初始化
- 遍历顺序
- 递归公式

## 动态规划解题思路

1. 确定状态是什么,然后再一个一个递推过去试试?
2. 如果从前往后递推不能确定的话,试试从后往前递推 (#120 三角形最小路径和, #931 下降路径最小和)
3. dp table是一维的还是二维的?
4. 先用穷举,再优化试试?
5. 将固定公式移项、变形试试?
6. 当前状态是否只与上一个状态有关?会不会和再上一个状态有关呢?
7. 当前状态是不是还与上一个状态的对立面有关?(如: 最大值, 最小值) (#1567 乘积为正数的最长子数组长度, #367 摆动序列)
8. 两个循环的先后顺序问题?(#322 零钱兑换, #518 零钱兑换2)